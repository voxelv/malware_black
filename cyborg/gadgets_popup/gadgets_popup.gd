extends Popup

signal part_update(part_type)

const part_node_names = ["eyes_row", "torso_row", "arms_row", "hands_row", "legs_row", "feet_row"]

onready var close_button = find_node("close_button")

var row_nodes = []

func _ready():
	
	close_button.connect("pressed", self, "close_button_pressed")
	
	for n in part_node_names:
		var node = find_node(n)
		row_nodes.append(node)
		node.get_update_button().connect("pressed", self, "update_button_pressed", [node.type])

func update_data(cyborg, live_sw=null):
	for row_node in row_nodes:
		var p = row_node.type
		row_node.set_software_color(mb_lib.WHITE)
		row_node.set_update_button_color(mb_lib.WHITE)
		row_node.set_update_button_disabled(true)
		if cyborg.has_part(p):
			row_node.visible = true
			row_node.set_software_str(cyborg.get_software_str(p))
		else:
			row_node.visible = false
	
	if live_sw != null:
		_update_colors(cyborg, live_sw)

func _update_colors(cyborg, live_sw):
	for row_node in row_nodes:
		var p = row_node.type
		if not cyborg.has_part(p):
			continue
		row_node.set_live_str(live_sw[p].get_str())
		if cyborg.get_software(p).less_than(live_sw[p]):
			row_node.set_software_color(mb_lib.RED)
			row_node.set_update_button_color(mb_lib.RED)
			row_node.set_update_button_disabled(false)
		else:
			row_node.set_software_color(mb_lib.GREEN)
			row_node.set_update_button_color(mb_lib.GRAY)
			row_node.set_update_button_disabled(true)

func update_button_pressed(type):
	emit_signal("part_update", type)

func close_button_pressed():
	hide()




