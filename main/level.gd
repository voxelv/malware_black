extends Node

# Node Names
const CYBORG_LIST = "cyborg_list"
const MISSION_LIST = "mission_list"
const MISSION_TIMER = "mission_timer"

# Preloads
var mission_preload = preload("res://mission/mission.tscn")
var cyborg_preload = preload("res://cyborg/cyborg.tscn")
var sw_version_preload = preload("res://utl/sw_version.gd")

# Variables
var credits = 0
var nodes = {
	CYBORG_LIST: null,
	MISSION_LIST: null,
	MISSION_TIMER: null,
}

const MISSION_ROLL_TYPE = "mission_roll_type"
const MISSION_ROLL_DESC = "mission_roll_desc"
var mission_roll = [
	{   
		MISSION_ROLL_TYPE: mb_lib.MISSION_ATTACK,
		MISSION_ROLL_DESC: "Test Description",
	},
	{
		MISSION_ROLL_TYPE: mb_lib.MISSION_DEFEND,
		MISSION_ROLL_DESC: "Test Description",
	},
	{
		MISSION_ROLL_TYPE: mb_lib.MISSION_ESCORT,
		MISSION_ROLL_DESC: "Test Description",
	},
	{
		MISSION_ROLL_TYPE: mb_lib.MISSION_AMBUSH,
		MISSION_ROLL_DESC: "Test Description",
	},
	{
		MISSION_ROLL_TYPE: mb_lib.MISSION_SURVEILLANCE,
		MISSION_ROLL_DESC: "Test Description",
	},
	{
		MISSION_ROLL_TYPE: mb_lib.MISSION_COUNTER_INTELLIGENCE,
		MISSION_ROLL_DESC: "Test Description",
	},
	{
		MISSION_ROLL_TYPE: mb_lib.MISSION_ASSASINATE,
		MISSION_ROLL_DESC: "Test Description",
	},
	{
		MISSION_ROLL_TYPE: mb_lib.MISSION_BODYGUARD,
		MISSION_ROLL_DESC: "Test Description",
	},
	{
		MISSION_ROLL_TYPE: mb_lib.MISSION_GUARD,
		MISSION_ROLL_DESC: "Test Description",
	},
	{
		MISSION_ROLL_TYPE: mb_lib.MISSION_INFILTRATE,
		MISSION_ROLL_DESC: "Test Description",
	},
	{
		MISSION_ROLL_TYPE: mb_lib.MISSION_SEARCH_AND_DESTROY,
		MISSION_ROLL_DESC: "Test Description",
	},
	{
		MISSION_ROLL_TYPE: mb_lib.MISSION_CONSTRUCT_OUTPOSTS,
		MISSION_ROLL_DESC: "Test Description",
	},
]
var next_mission = 0

var current_cyborg_part_versions = {
	mb_lib.CYBORG_PART_TYPE_EYES: sw_version_preload.new().set_version(1, 2, 3),
	mb_lib.CYBORG_PART_TYPE_ARMS: sw_version_preload.new().set_version(2, 3, 4),
	mb_lib.CYBORG_PART_TYPE_HANDS: sw_version_preload.new().set_version(3, 4, 5),
	mb_lib.CYBORG_PART_TYPE_TORSO: sw_version_preload.new().set_version(4, 5, 6),
	mb_lib.CYBORG_PART_TYPE_LEGS: sw_version_preload.new().set_version(5, 6, 7),
	mb_lib.CYBORG_PART_TYPE_FEET: sw_version_preload.new().set_version(6, 7, 8),
}

func _input(event):
	if event is InputEventKey and event.scancode == KEY_ESCAPE and event.pressed:
		mission_select_button_pressed(-1)
	if event is InputEventKey and event.scancode == KEY_SPACE and event.pressed:
		var new_cyborg = cyborg_preload.instance().set_level(self)
		nodes[CYBORG_LIST].add_child(new_cyborg)

func _ready():
	for node_name in nodes:
		nodes[node_name] = find_node(node_name)
	
	nodes[MISSION_TIMER].connect("timeout", self, "mission_timer_timeout")

func new_mission():
	if next_mission < len(mission_roll):
		var new_mission = mission_preload.instance()
		var next_mission_info = mission_roll[next_mission]
		nodes[MISSION_LIST].add_child(new_mission)
		new_mission.set_info(next_mission_info[MISSION_ROLL_TYPE], next_mission_info[MISSION_ROLL_DESC])
		new_mission.nodes["select_button"].connect("pressed", self, "mission_select_button_pressed", [new_mission.get_position_in_parent()])
		next_mission += 1
	else:
		nodes[MISSION_TIMER].stop()

func mission_timer_timeout():
	new_mission()

func mission_select_button_pressed(idx):
	for m in nodes[MISSION_LIST].get_children():
		m.set_selected(false)
	var missions = nodes[MISSION_LIST].get_children()

	if 0 <= idx and idx < len(missions):
		missions[idx].set_selected(true)

func get_cyborg_part_version_for_type(type):
	return(current_cyborg_part_versions[type])








